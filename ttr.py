from pyrogram import Client, filters
from pyrogram.types import Message
import time

# ---------- CONFIG ----------
API_ID = 29680263           # Telegram API ID
API_HASH = "a251c8203284c9fe7812f418ec8aa3a9"
SESSION = "my_account"     # Pyrogram session name
OWNER_ID = 6577308099       # numeric Telegram ID
COOLDOWN_SECONDS = 300     # à§« à¦®à¦¿à¦¨à¦¿à¦Ÿ cooldown

# ---------- VARIABLES ----------
sleep_mode = False
cooldowns = {}  # user_id : last_active_time

# ---------- INIT CLIENT ----------
app = Client(
    SESSION,
    api_id=API_ID,
    api_hash=API_HASH
)

# ---------- OFFLINE MESSAGE ----------
OFFLINE_MSG = (
    "ðŸ’­ Iâ€™m offline for a while...\n"
    "No replies, no calls â€” just a little peace and silence.\n"
    "If itâ€™s important, leave your message. Iâ€™ll be back when Iâ€™m meant ðŸŒ™.\n\n"
    "âœ¨ This text was automatically generated by Docker"
)

# ===== COMMANDS =====
@app.on_message(filters.command("sleep") & filters.user(OWNER_ID))
async def activate_sleep(_, msg: Message):
    global sleep_mode
    sleep_mode = True
    await msg.reply_text("Sleep mode activated. Auto-reply is now ON.")

@app.on_message(filters.command("off") & filters.user(OWNER_ID))
async def deactivate_sleep(_, msg: Message):
    global sleep_mode
    sleep_mode = False
    await msg.reply_text("Sleep mode deactivated. Auto-reply is now OFF.")

@app.on_message(filters.command("status") & filters.user(OWNER_ID))
async def status_check(_, msg: Message):
    status = "ON" if sleep_mode else "OFF"
    await msg.reply_text(f"Auto-reply status: {status}")

# ===== MARK SELF ACTIVE =====
@app.on_message(filters.me)
async def mark_active(_, msg: Message):
    cooldowns[msg.chat.id] = time.time()

# ===== AUTO-REPLY =====
@app.on_message(filters.private | filters.group)
async def auto_reply(_, msg: Message):
    global sleep_mode
    if not sleep_mode:
        return

    # à¦¨à¦¿à¦œà§‡à¦° à¦®à§‡à¦¸à§‡à¦œ à¦¬à¦¾à¦¦
    if msg.from_user and msg.from_user.is_self:
        return

    # à¦¬à¦Ÿ à¦¬à¦¾à¦¦
    if msg.from_user and msg.from_user.is_bot:
        return

    try:
        user_id = msg.chat.id
        now = time.time()
        last_time = cooldowns.get(user_id, 0)

        # à§« à¦®à¦¿à¦¨à¦¿à¦Ÿ cooldown à¦šà§‡à¦•
        if now - last_time < COOLDOWN_SECONDS:
            return

        # à¦ªà§à¦°à¦¾à¦‡à¦­à§‡à¦Ÿ à¦šà§à¦¯à¦¾à¦Ÿà§‡ à¦¸à¦¬ reply
        if msg.chat.type == "private":
            cooldowns[user_id] = now
            await msg.reply_text(OFFLINE_MSG)
            return

        # à¦—à§à¦°à§à¦ªà§‡ à¦¶à§à¦§à§ à¦¨à¦¿à¦°à§à¦¦à¦¿à¦·à§à¦Ÿ username à¦®à§‡à¦¨à¦¶à¦¨ à¦¥à¦¾à¦•à¦²à§‡ reply
        if msg.chat.type in ["group", "supergroup"]:
            if msg.entities:  # à¦¯à¦¦à¦¿ à¦•à§‹à¦¨ mention à¦¥à¦¾à¦•à§‡
                mentioned_usernames = [msg.text[ent.offset:ent.offset+ent.length] for ent in msg.entities if ent.type == "mention"]
                if "@professor_cry" in mentioned_usernames:
                    cooldowns[user_id] = now
                    await msg.reply_text(OFFLINE_MSG)
            return

    except Exception as e:
        print("Auto-reply skipped due to:", e)

# ===== MAIN =====
if __name__ == "__main__":
    print("Userbot running in background... Use /sleep, /off, /status from your Telegram account.")
    app.run()
